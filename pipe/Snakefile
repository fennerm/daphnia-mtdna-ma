"""Megadaph mtDNA sequence processing pipeline

Snakemake: https://snakemake.readthedocs.io/en/stable/

Input files: Paired end whole genome short read illumina sequencing from 
D. pulex and D. magna
"""
import os

# ==============================================================================
# Set up
# ==============================================================================

configfile: "config.yml"

SAMPLE, PAIR = glob_wildcards("input/reads/{sample}.{pair}.fastq.gz")
SAMPLE = sorted(list(set(SAMPLE)))
PAIR = sorted(list(set(PAIR)))
PULEX = [x for x in SAMPLE if x.startswith(('L', 'T'))]
MAGNA = [x for x in SAMPLE if x.startswith(('F', 'G', 'I'))]
SPECIES = ['pulex', 'magna']

ROTATION = ['og', 'rot']

# ==============================================================================
# Helper functions
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Used to match the correct species or reference genome to the input files
# ==============================================================================

def species(wildcards):
    """Determine the species from the sample wildcard"""
    if wildcards.sample in PULEX:
        spp = 'pulex'
    elif wildcards.sample in MAGNA:
        spp = 'magna'
    else:
        raise ValueError('Could not assign species to sample')
    return spp


def mtdna_fasta_id(wildcards):
    """Get the name of the mtdna contig from the sample wildcard"""
    fasta = os.path.join('ref', species(wildcards) + '.mt.og.fa')
    with open(fasta, 'r') as f:
        faid = f.readline()
    return faid

def reference(wildcards):
    """Get the path to the original or rotated mtDNA reference"""
    return os.path.join("ref",
                        '.'.join([species(wildcards), "mt",
                                  wildcards.rotation, "fa"]))

def combined_reference(wildcards):
    """Get the path to the combined nuclear + mtDNA reference"""
    return os.path.join("ref", species(wildcards) + ".all.fa")

def prefix(wildcards):
    """Return the filename prefix of the input file"""
    return os.path.splitext(wildcards.input)[0]

# ==============================================================================
# Pipeline
# ==============================================================================

rule all:
    input:
        expand('ref/{species}.mt.rot.fa', species=SPECIES),
        expand(
            "output/local_realignment/{sample}.{rotation}.bam",
            sample=SAMPLE, rotation=ROTATION),
        "output/multiqc/multiqc.html",
        expand('ref/{species}.all.fa', species=SPECIES)

rule rotate_reference:
    input:
        'ref/{species}.mt.og.fa'
    output:
        'ref/{species}.mt.rot.fa'
    shell:
        "scripts/rotate_ref.py {input} {output}"

rule combine_mt_and_nuc_references:
    input:
        nuc = 'ref/{species}.nuc.fa',
        og = 'ref/{species}.mt.og.fa',
        rot = 'ref/{species}.mt.rot.fa'
    output:
        'ref/{species}.all.fa'
    shell:
        "cat {input.og} {input.rot} {input.nuc} > {output}"


rule raw_fastqc:
    input:
        fwd_reads = 'input/reads/{sample}.R1.fastq.gz',
        rev_reads = 'input/reads/{sample}.R2.fastq.gz'
    output:
        'output/raw_fastqc/{sample}.R1_fastqc.html',
        'output/raw_fastqc/{sample}.R2_fastqc.html',
    params:
        outdir = 'output/raw_fastqc'
    shell:
        "fastqc -o {params.outdir} {input.fwd_reads} {input.rev_reads}"

rule trim_adapters:
    input:
        fwd_reads = 'input/reads/{sample}.R1.fastq.gz',
        rev_reads = 'input/reads/{sample}.R2.fastq.gz'
    output:
        fwd_reads = 'output/trim_adapters/{sample}.R1.fastq.gz',
        rev_reads = 'output/trim_adapters/{sample}.R2.fastq.gz'
    log: "output/trim_adapters/log/{sample}.log"
    params:
        ref = config['adapters'],
        k = '23',
        ktrim = 'r',
        mink = '4',
        hdist = '1'
    shell:
        "bbduk.sh in={input.fwd_reads} in2={input.rev_reads} threads=1 "
        "out={output.fwd_reads} out2={output.rev_reads} ref={params.ref} "
        "k={params.k} ktrim={params.ktrim} mink={params.mink} "
        "hdist={params.hdist} tpe tbo 2> {log}"

rule quality_trim:
    input:
        fwd_reads = 'output/trim_adapters/{sample}.R1.fastq.gz',
        rev_reads = 'output/trim_adapters/{sample}.R2.fastq.gz'
    output:
        fwd_reads = 'output/quality_trim/{sample}.R1.fastq.gz',
        rev_reads = 'output/quality_trim/{sample}.R2.fastq.gz'
    log:
        "output/quality_trim/log/{sample}.paired.log"
    params:
        qtrim = 'rl',
        trimq = '20',
        minlen = '50'
    shell:
        "bbduk.sh in={input.fwd_reads} in2={input.rev_reads} "
        "out={output.fwd_reads} out2={output.rev_reads} threads=1 "
        "qtrim={params.qtrim} trimq={params.trimq} minlen={params.minlen} "
        "2> {log}"

rule clean_fastqc:
    input:
        'output/quality_trim/{sample}.{pair}.fastq.gz'
    output:
        'output/clean_fastqc/{sample}.{pair}_fastqc.html'
    params:
        outdir='output/clean_fastqc'
    shell:
        "fastqc -o {params.outdir} {input}"

rule multiqc:
    input:
        expand(
            'output/clean_fastqc/{sample}.{pair}_fastqc.html',
            sample=SAMPLE, pair=PAIR),
        expand(
            'output/raw_fastqc/{sample}.{pair}_fastqc.html',
            sample=SAMPLE, pair=PAIR),
    output:
        'output/multiqc/multiqc.html'
    shell:
        'multiqc -d -n {output} .'

rule competitive_align:
    input:
        fwd_reads = "output/quality_trim/{sample}.R1.fastq.gz",
        rev_reads = "output/quality_trim/{sample}.R2.fastq.gz",
        ref = combined_reference
    output:
        "output/competitive_align/{sample}.bam"
    params:
        max_insert_size = 16000
    log:
        "output/competitive_align/log/{sample}.log"
    shell:
        "scripts/align_and_sort.py -1 {input.fwd_reads} "
        "-2 {input.rev_reads} -x {input.ref} -X {params.max_insert_size} "
        "> {output} 2> {log}"

rule extract_mt_reads:
    input:
        bam = "output/competitive_align/{sample}.bam"
    output:
        fwd_reads = "output/mt_aligned/{sample}.R1.fastq",
        rev_reads = "output/mt_aligned/{sample}.R2.fastq"
    params:
        csome = mtdna_fasta_id
    shell:
        "samtools view -b {params.csome} {input.bam} | picard SamToFastq "
        "I=/dev/stdin F={output.fwd_reads} F2={output.rev_reads}"

rule align_to_rotated_mt:
    input:
        fwd_reads = "output/mt_aligned/{sample}.R1.fastq",
        rev_reads = "output/mt_aligned/{sample}.R2.fastq",
        ref = reference
    output:
        "output/align_to_rotated_mt/{sample}.{rotation}.bam"
    params:
        max_insert_size = 16000
    log:
        "output/align_to_og_and_rot_mt/log/{sample}.log"
    shell:
        "scripts/align_and_sort.py -1 {input.fwd_reads} "
        "-2 {input.rev_reads} -x {input.ref} -x {params.max_insert_size} "
        "--very-sensitive --rg-id={wildcards.sample} "
        "--rg=lib:{wildcards.sample} --rg=pl:illumina "
        "--rg=sm={wildcards.sample} > {output} 2> {log}"


rule remove_duplicates:
    input:
        "output/align_to_rotated_mt/{sample}.{rotation}.bam"
    output:
        "output/remove_duplicates/{sample}.{rotation}.bam"
    log:
        "output/remove_duplicates/log/{sample}.{rotation}.log"
    shell:
        "picard MarkDuplicates I={input} O={output} REMOVE_DUPLICATES=True "
        "METRICS_FILE={log} CREATE_INDEX=True"

rule local_realignment_targets:
    input:
        bam = "output/remove_duplicates/{sample}.{rotation}.bam",
        ref = reference
    output:
        "output/local_realignment_targets/{sample}.{rotation}.intervals"
    shell:
        "gatk -T RealignerTargetCreator -R {input.ref} -I {input.bam} -o "
        "{output}"

rule local_realignment:
    input:
        bam = "output/remove_duplicates/{sample}.{rotation}.bam",
        inter = "output/local_realignment_targets/{sample}.{rotation}.intervals"
    output:
        "output/local_realignment/{sample}.{rotation}.bam"
    params:
        ref = reference,
        max_move = '500',
        max_cons_reads = '300',
        max_realignment_reads = '1000000'
    log:
        "output/local_realignment/log/{sample}.{rotation}.log"
    shell:
        "gatk -T IndelRealigner -R {params.ref} -I {input.bam} -o {output} "
        "--targetIntervals {input.inter} --maxReadsForRealignment "
        "{params.max_realignment_reads} --maxPositionMoveAllowed "
        "{params.max_move} --maxReadsForConsensuses {params.max_cons_reads} "
        "--log_to_file {log}"
